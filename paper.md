Group Members:
Rosell, Josiah Lamuel D.
Garcia, Arianna Nicole V.
Pecayo, Miguel Alfonso
When we began this project, we felt both confident and uncertain. Although we had basic knowledge of Java and a theoretical understanding of data structures, building everything from scratch made us realize how different theory is from actual implementation. Our goal was to deepen our understanding of how common structures like ArrayLists, LinkedLists, Stacks, Queues, and Trees function internally. As a group with varying skill levels, we expected challenges but also saw the project as an opportunity to strengthen our fundamentals and improve our problem-solving abilities.
Many difficulties surfaced early, especially when working with LinkedLists. Managing nodes and pointers required a level of precision we were not used to, and small reference mistakes caused broken chains or incorrect outputs. Implementing search and sort without built-in Java functions heightened the challenge; writing QuickSort and MergeSort manually made us aware of how easy it is to introduce logical errors even when the code “looks right.”
Despite the challenges, we gained a far deeper understanding of how data structures actually work. Implementing ArrayLists taught us about dynamic resizing and the cost of shifting elements. Working with LinkedLists made us appreciate pointer manipulation and the tradeoffs of sequential access. Manual sorting algorithms showed us why algorithm design is crucial and how performance varies based on structure and strategy. Through working with Trees, recursion became less intimidating and more natural, especially for traversal and insertion. Overall, we learned to think not just about code that works, but about how data flows through memory and how operations impact efficiency.
Our problem-solving process evolved significantly. We relied heavily on print statements to track pointer changes, array states, and recursion paths. This simple strategy revealed misunderstandings we initially overlooked. Creating diagrams of nodes and arrays helped us reason through logic more clearly than code alone. We practiced structured debugging: isolate the problem, test simple cases, adjust, and re-test. Collaboration played a major role discussing issues aloud often led us to solutions more quickly than working individually. Reviewing each other’s code line-by-line helped catch logical issues and ensured consistency across all data structures.
Beyond technical knowledge, we developed stronger coding discipline, clearer planning habits, and better communication. We realized the value of thoughtful variable naming, modular functions, and consistent formatting. Teamwork improved as we divided tasks, explained code to one another, and integrated our work into a single, coherent program. Creating the video demonstration strengthened our ability to explain technical concepts clearly and present program behavior in a structured way.

This project strengthened our Java foundations and helped us move from theoretical understanding to practical mastery. We gained confidence working with memory, pointers, recursion, and algorithmic thinking. We now better appreciate the complexity behind standard Java classes and recognize why efficient data structure design matters in real-world systems. Most importantly, we learned that perseverance and clear reasoning can overcome even the most confusing bugs.
